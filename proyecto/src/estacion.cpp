#include <math.h>
#include "modelos.h"

#ifdef KM
// Coordenadas de los centroides 
const float centroides[3][3] = {
    {21.99032567, 22.74712587, 21.95231369},  // Invierno
    {28.14988811, 27.55429171, 27.50687313},  // Primavera-Otoño
    {30.99140559, 32.41307892, 33.00371928}   // Verano
};

// Función para calcular la distancia euclidiana considerando solo valores no nulos
float calcular_distancia_km(float lectura_adc[3], const float centroide[3]) {
    float suma = 0;

    // Calcular la distancia considerando solo las lecturas de ADC diferentes de 0
    for (int i = 0; i < 3; i++) {
        if (lectura_adc[i] != 0) {  // Ignorar los valores que sean 0
            suma += pow(lectura_adc[i] - centroide[i], 2);
        }
    }

    return sqrt(suma);
}
#endif 

#ifdef KNN
 
    Point dataset[NUM_POINTS];              
// Función para calcular la distancia euclidiana entre dos puntos
double euclidean_distance(Point a, Point b) {
	double ds1 = 0, ds2 = 0, ds3 = 0;
	

		if(b.s1 != 0) ds1 = pow(a.s1 - b.s1, 2);

		if(b.s2 != 0) ds2 = pow(a.s2 - b.s2, 2);

		if(b.s3 != 0) ds3 = pow(a.s3 - b.s3, 2);

		return sqrt(ds1 + ds2+ ds3);

    
}

// Función para encontrar los K vecinos más cercanos
void find_k_nearest_neighbors(Point dataset[], Point test_point, int k, int neighbors[]) {
    double distances[NUM_POINTS];
    int i, j;

    // Calcular las distancias entre el punto de prueba y todos los puntos en el dataset
    for (i = 0; i < NUM_POINTS; i++) {
        distances[i] = euclidean_distance(dataset[i], test_point);
    }

    // Ordenar los puntos por distancia usando una selección simple de k vecinos
    for (i = 0; i < k; i++) {
        double min_distance = 1e9;
        int min_index = -1;
        for (j = 0; j < NUM_POINTS; j++) {
            if (distances[j] < min_distance) {
                min_distance = distances[j];
                min_index = j;
            }
        }
        neighbors[i] = dataset[min_index].label;  // Almacenar la etiqueta del vecino
        distances[min_index] = 1e9;               // Excluir el punto ya seleccionado
    }
}

// Función para clasificar el punto de prueba basado en la mayoría de las etiquetas
int classify(Point dataset[], Point test_point, int k) {
    int neighbors[K];
    int i, label1 = 0, label2 = 0, label3 = 0;

    // Encontrar los k vecinos más cercanos
    find_k_nearest_neighbors(dataset, test_point, k, neighbors);

    // Contar las etiquetas de los vecinos
    for (i = 0; i < k; i++) {
        if (neighbors[i] == 1) label1++;
        else if (neighbors[i] == 2) label2++;
        else if (neighbors[i] == 3) label3++;
    }
        if ( label1 >= label2 && label1 >= label3 )
        return 1;
    else

        if ( label2 > label3 )
            return 2;
        else
            return 3;
} 
 
    double s1[NUM_POINTS] = {24.946,25.101,26.195,23.364,25.224,23.067,25.967,27.468,25.605,23.106,24.646,24.008,22.933,23.361,22.181,23.583,25.455,24.616,21.424,25.371,25.025,22.64,23.134,24.254,22.305,22.54,22.514,24.143,23.574,22.732,22.067,22.904,22.166,24.655,20.883,22.273,21.388,24.231,23.487,21.699,22.078,22.963,22.642,19.279,20.006,21.552,23.325,22.426,20.717,22.422,20.928,20.307,21.623,20.965,21.169,20.204,21.214,20.324,19.857,22.027,20.889,19.436,22.24,19.828,20.73,19.328,22.655,22.595,20.361,19.535,28.191,32.201,31.9,30.248,30.245,33.156,30.983,29,32.092,31.187,32.053,32.12,28.066,30.352,33.234,30.606,29.934,30.598,31.918,30.354,32.136,29.487,28.893,29.478,29.627,30.433,32.282,28.655,28.043,29.128,28.144,30.102,29.763,28.813,30.383,28.134,29.372,29.887,29.302,29.574,28.945,28.723,29.009,29.271,28.576,29.221,30.026,26.624,28.43,29,28.768,30.836,29.718,29.295,29.425,27.427,29.231,28.11,26.238,25.974,29.109,27.521,28.157,27.762,26.937,27.441,28.44,25.467,28.223,26.84,32.942,34.372,33.802,31.417,33.064,35.468,32.583,30.344,30.995,32.034,34.149,32.684,33.619,33.14,32.821,34.941,31.695,31.79,32.926,34.269,34.491,30.99,33.814,32.272,32.826,30.976,32.675,32.108,32.211,34.632,34.289,33.58,31.631,31.582,33.244,30.739,32.767,32.004,33.23,31.47,32.573,30.776,32.804,32.447,30.762,32.44,32.747,31.627,33.483,31.814,30.478,32.115,31.437,31.704,30.797,33.356,30.926,32.279,32.09,32.984,31.299,32.813,33.356,32.086,31.865,32.824,32.203,34.392,32.454,30.033};
    double s2[NUM_POINTS] = {26.235,25.054,25.991,25.787,25.849,24.988,25.215,25.649,25.143,24.817,25.664,25.295,25.175,24.12,24.917,23.942,24.831,25.081,24.556,24.508,24.157,24.593,23.238,24.343,23.626,23.308,23.995,22.698,22.904,23.236,23.786,23.478,23.648,22.932,22.441,22.319,23.008,22.972,23.379,23.412,23.279,23.334,22.688,23.059,23.375,22.427,23.056,23.562,22.8,22.527,23.493,22.358,23.519,23.084,22.757,22.341,22.055,22,22.828,22.155,22.112,22.076,22.6,22.182,21.416,21.185,21.296,20.95,20.957,20.844,29.784,30.51,30.553,30.107,30.16,31.038,30.435,30.669,30.286,29.411,29.34,29.805,30.087,29.974,29.417,29.514,28.949,28.761,29.341,28.948,28.834,28.359,29.577,28.672,29.097,28.996,29.108,28.966,28.492,28.057,28.938,28.855,27.616,27.655,28.564,27.928,27.574,28.414,27.61,27.712,28.103,27.598,28.282,27.786,28.683,28.62,28.471,28.489,28.344,28.202,27.702,28.906,29.027,28.926,28.665,27.936,27.951,28.101,28.18,28.156,27.541,27.95,27.55,27.307,28.246,27.638,27.144,26.619,26.777,26.259,34.815,35.796,35.279,35.19,34.481,35.547,35.145,34.989,35.713,34.734,34.443,34.782,35.309,34.748,34.213,34.156,34.514,34.771,33.562,34.537,33.973,34.359,34.195,34.148,34.553,33.859,33.084,34.25,33.931,33.889,34.024,33.772,33.084,33.823,33.126,34.157,33.138,34.528,33.712,34.67,34.369,33.428,34.108,34.679,34.425,33.608,34.911,33.655,35.09,34.699,34.967,33.973,34.756,34.998,34.092,33.934,33.812,34.653,33.8,34.778,34.418,33.684,34.553,34.032,34.324,34.441,34.476,34.059,34.199,34.303};
    double s3[NUM_POINTS] = {25.678,24.017,26.257,23.187,25.099,24.026,25.253,24.599,24.463,23.412,24.422,25.722,25.218,24.278,24.255,24.942,25.059,25.069,23.92,22.563,25.205,23.939,24.778,24.894,24.327,23.091,22.999,24.081,23.922,22.414,22.226,21.927,20.818,22.381,21.154,23.432,22.369,22.447,21.072,23.434,23.624,23.586,21.31,21.527,22.801,21.797,22.646,22.389,20.885,22.631,21.799,20.968,22.189,20.592,21.591,20.77,22.087,21.656,20.167,20.182,21.857,23.54,21.289,21.975,22.926,20.637,21.005,20.809,21.588,22.739,30.027,31.406,29.314,28.502,30.988,29.438,31.544,30.592,29.984,30.622,30.21,30.487,30.395,30.262,29.05,30.393,29.687,28.891,30.781,31.444,30.782,29.979,29.218,29.64,29.418,29.663,28.979,28.297,29.293,28.228,28.486,29.754,28.266,28.936,28.384,27.913,28.449,28.233,27.666,27.69,29.397,28.671,28.587,27.602,27.645,26.362,28.141,26.717,28.613,27.727,27.352,27.454,27.651,26.654,26.926,28.129,25.325,27.961,28.098,27.536,27.756,27.471,27.932,26.999,26.076,26.684,27.91,27.407,26.397,28.112,35.671,35.65,35.255,37.054,35.326,34.62,35.634,37.43,34.022,35.063,35.032,33.955,35.146,35.912,37.01,35.232,35.335,36.393,35.578,35.654,34.995,37.079,36.811,34.149,34.943,34.864,35.89,34.526,35.526,33.741,34.904,35.147,33.607,34.294,35.483,36.463,34.935,34.682,35.709,34.731,33.656,34.223,33.338,34.685,34.781,33.69,33.542,35.135,32.228,34.92,33.484,35.677,34.656,33.183,33.267,34.789,32.915,34.324,34.078,32.978,34.654,33.895,34.058,34.051,34.761,33.926,34.937,33.094,34.16,33.228};
    double estacion[NUM_POINTS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3};

void knn_init(void){
    for(int j = 0;j<NUM_POINTS;++j){
		dataset[j].s1 = s1[j];
		dataset[j].s2 = s2[j];
		dataset[j].s3 = s3[j];
		dataset[j].label = estacion[j];
	} 
    
}


#endif
// Función KNN para determinar la estación basándose en los centroides y los valores del ADC
int determinar_estacion(float lectura_adc[3]) {
    #ifdef KM
    float distancias[3];  // Distancias a los tres centroides

    // Calcular las distancias a cada uno de los centroides
    for (int i = 0; i < 3; i++) {
        distancias[i] = calcular_distancia_knn(lectura_adc, centroides[i]);
    }

    // Encontrar el índice del centroide más cercano (distancia mínima)
    float min_distancia = distancias[0];
    int estacion_idx = 0;  // Asumimos que la estación inicial es Invierno (índice 0)

    for (int i = 1; i < 3; i++) {
        if (distancias[i] < min_distancia) {
            min_distancia = distancias[i];
            estacion_idx = i;
        }
    }

    // Devolver la estación correspondiente según el índice más cercano
    return estacion_idx+1;
    
    #endif 

    #ifdef KNN


    Point test_point = { lectura_adc[0],  lectura_adc[1], lectura_adc[2]};

	int label = classify(dataset, test_point, K);
	
	return label;
	

    #endif
}